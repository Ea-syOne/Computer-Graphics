### Cartesian Coordinate System
3차원 좌표계의 경우 일반적으로 Cartesian Coordinate System을 사용한다. <br>
Cartesian Coordinate System은 z축의 방향에 따라 두 종류로 나뉘는데, Right-handed와 Left-handed로 나뉘게 된다.
*  Right-handed: z축을 중심으로 물체를 양의 방향으로 회전시킬 때 반시계 방향으로 회전하는 좌표계. OpenGL이 대표적으로 이러한 좌표계를 사용한다. 
*  Left-handed: 위와 같은 조건에서 시계방향으로 회전하는 좌표계. Unity, Unreal 등 게임 엔진은 이러한 좌표계를 사용한다. 이 둘은 정반대의 회전 결과를 나타내기 때문에 자신이 사용할 프레임워크가 어떠한 좌표계인지 인지하는 것이 중요하다. 

### 3D Transformation
#### Scale, Shear, Translation
직관적으로 2D Transformation에서 한차원 확장시킨 행렬을 사용하면 된다. 
#### Rotation
Rotation의 경우 x축 회전 시엔 x축 값은 변하지 않기 때문에 x 축 값만 고정한 채 나머지는 2D에서처럼 회전 계수를 붙여주면 된다.
*  R(x,θ) = [1 0 0 | 0 cosθ -sinθ | 0 sinθ cosθ].

단 x, z축과 달리 y축은 지면에 수직인 축이기 때문에 행렬이 좀 달라진다.
*  R(y,θ) = [cosθ 0 **sinθ** | 0 1 0 | **-sinθ** 0 cosθ].

이 Rotation 값은 Right-handed 기준으로, Left-handed일 경우 θ를 모두 -θ로 바꾼 결과로 수정해주면 된다.
#### Homogeneous Coordinates
3차원의 경우 4 * 4 행렬로 표현하며, 2D일 때에서 한 행, 한 열 많다는 점만 빼면 동일하다.

### 3D Transformation in OpenGL
OpenGL에서는 Current_Transformation_Matrix를 state로써 저장하고 있으며, 이를 기반으로 Transformation을 표현한다. 이와 관련된 함수들은 다음과 같다.<br>
#### glLoadIdentity()
Current Transformation Matrix를 Identity Matrix로 초기화시키는 함수. 원래 상태의 Object로 되돌리는 데에 주로 사용된다.
#### glScale(x,y,z)
Object를 x축으로 x배, y축으로 y배, z축으로 z배하는 행렬을 만들어 Current Matrix의 오른쪽에 곱하는 함수.
#### glRotate(angle,x,y,z)
Object를 angle만큼 회전시키는 행렬을 만들어 Current Matrix 오른쪽에 곱하는 함수, angle은 degree 단위로 받는다. 이때 회전 축의 경우 x, y, z에 0 또는 1 값을 넣어 지정하게 된다.
#### glTranslate(x,y,z)
Object를 x축으로 x, y축으로 y, z축으로 z만큼 이동시키는 행렬을 만들어 Current Matrix의 오른쪽에 곱하는 함수.
#### glMultMatrix(m)
사용자가 구현한 행렬 m을 Current Matrix 오른쪽에 곱하는 함수. 주의할 점으로는 numpy를 사용할 때 numpy와 glMultMatrix가 받는 행렬의 읽는 순서가 다르다는 점이다. numpy는 행단위로 읽는 것을 기준으로 구현된 반면, glMultMatrix는 열단위로 읽어들인다. 따라서 numpy를 이용해 구현한 행렬을 glMultMatrix의 인자로 전달할 때 반드시 numpy_matrix.T와 같이 Transpose해줘야 의도대로 해석한다는 것을 주의해야 한다.
#### Composing Transformation in OpenGL
OpenGL에서의 행렬의 곱은 역순으로 반영된다. 즉 Translate Matrix T와 Rotation Matrix R이 있을 때 TRp라는 것은 p를 회전한 후, 평행이동하는 것을 의미한다. 
