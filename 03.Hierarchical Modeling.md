### Local Frame
Global Frame의 경우 기본적으로 Standard Basis Vectors [1,0,0], [0,1,0], [0,0,1]과 원점 (0,0,0)으로 표현된다.<br>
Global Frame에 Transformation Matrix M을 적용시킨다는 것은 각 Basis Vector와 Origin에도 Transformation을 적용시키는 것과 같다고 볼 수 있다. [ m11 m12 m13 ux | m21 m22 m23 uy | m31 m32 m33 yz | 0 0 0 1 ]과 같은 행렬을 각 Basis Vector와 Origin에 적용한다 생각하면,
*  axis vector: x축 vector, [1 | 0 | 0 | 0 ]에 M을 곱하면 [ m11 | m21 | m31 | 0 ]이 나온다. 이는 M의 1열과 동일하다.<br>마찬기지로 y, z축 vector의 경우도 Transformation을 적용시키면 M의 2, 3열과 동일한 vector가 나온다.
*  origin point: 원점의 경우 [ 0 | 0 | 0 | 1 ]로 표현 가능하다. 원점에 M을 적용시킬 경우 M의 4열과 같은 point가 나온다.

이로부터 알 수 있는 사실은 Global Frame에 대해 어떠한 Object에 Transformation Matrix M을 적용시킨다는 것은, Global Frame에 대해 M의 1, 2, 3 열을 Basis Vector로 하고, 원점이 (ux, uy, uz)인 Local Frame의 원점에 해당 Object를 옮겨놓는 것이라고 할 수 있다. 

### Frame간의 관계
일반적으로 Frame을 구분할 땐 Frame {0}, Frame {1}과 같이 { }를 사용해 표현한다. 또한 Frame {k}에서 바라본 점 p의 좌표를 p{k}라고 표현한다(그 동안은 암묵적으로 p{global}을 p라 표현한 셈). <br>
만약 임의의 Frame {0}와, Frame {0}에 대해 상술한 행렬 M으로 정의되는 Local Frame을 Frame {1}이라 할 경우, p{1} = (x, y, z)라 한다면, p{0}의 표현은 p{0} = M * p{1}과 같다. 이는 Frame {0}에 (x,y,z)란 point p0가 있다고 가정하면, p0를 M만큼 transform 한 결과가 Frame {0}에서 바라보는 p{1}과 동일한 결과이기 때문이다. <br>

### Composing Transformation
Frame {0}, Frame {0}에 대해 평행이동 행렬 T로 정의되는 Local Frame {1}, {1}에 대해 회적 행렬 R로 정의되는 Local Frame {2}가 있다고 가정하자. 점 p를 {2}에서 본 p{2} = (x,y,z)의 경우 {0}에 대해 표현하기 위해선 다음과 같은 과정이 요구된다. 
1.  {1}에 대해 표현되는 p의 좌표 p{1} = R * p{2}. 
2.  {0}에 대해 표현되는 p의 좌표 p{0} = T * p{1}. 이때 p{1} = R * p{2}이므로 p{0} = T * R * p{2}.

p에 적용된 Transformation Matrix의 순서는 R -> T 순서이다. 따라서 p{0} = T * R * p{2}란 식에서 Transformation은 Rotation -> Translation 순서임을 알 수 있다. 이것이 이전 Composing Transformation에서 언급된 행렬의 곱이 역순으로 반영되는 이유이다.

### Hierarchical Modeling
Model이 각 part가 종속된 subparts를 갖는 Tree 구조로 표현되는 Modeling을 의미한다.<br>
각 Child는 자기 자신의 Local Frame을 갖고 있으며, 각 Child의 동작은 Parent의 Local Frame에 대해 표현된다. 관련 용어는 다음과 같다.
*  Joint: 서로 다른 두 part를 연결하는 부분. 인체로 치면 관절의 역할. 실질적인 움직임이 허용되는 구간. 
*  Link: 두 Joint 사이의 Rigid Object. Link는 움직이지 않는다. 인체로 치면 팔목, 종아리, 몸통 등.
*  End Effector: Tree로 치면 Leaf 부분. 더 이상 Child가 없는 말단. 인체로 치면 손끝, 발끝.

#### Hierarchical Modeling in OpenGL
OpenGL에서의 Hierarchical Modeling은 Matrix Stack으로 구현된다. Stack은 Tree를 Traverse하기 좋은 자료구조인데, 각 Node에 진입할 때엔 해당 Node Matrix를 Push하고, Parent Node로 빠져나갈 땐 Pop을 하면 되기 때문이다. <br>
##### glPushMatrix
Stack에 Current Matrix를 Push하는 함수이다. 
##### glPopMatrix
Stack 최상단 Matrix를 Pop하는 함수이다. glPopMatrix를 사용할 땐 반드시 glPushMatrix와 짝을 맞춰주는 것이 중요하다.
##### glMatrixMode
Matrix Stack의 종류를 지정해주는 함수이다. 가장 자주쓰는 Mode에는 GL_MODELVIEW와 GL_PROJECTION이 존재한다. 이러한 종류는 Lighting 관련 결과물에 영향을 미치기 때문에 사용하는 Transformation Function에 따라 잘 지정해줘야 한다.
*  GL_PROJECTION: gluPerspective(), glOrtho()와 같은 Projection Transformation을 사용할 경우.
*  GL_MODELVIEW: gluLookAt(), glTranslate()와 같은 Modeling & Viewing Transformation을 사용할 경우. 

일반적으로 glLoadIdentity()이전에 MatrixMode를 지정해준다. 
